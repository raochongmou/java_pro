[网页](https://www.baidu.com/s?ie=utf-8&fr=bks0000&wd=冒泡排序)[新闻](http://news.baidu.com/ns?tn=news&cl=2&rn=20&ct=1&fr=bks0000&ie=utf-8&word=冒泡排序)[贴吧](https://tieba.baidu.com/f?ie=utf-8&fr=bks0000&kw=冒泡排序)[知道](https://zhidao.baidu.com/search?pn=0&&rn=10&lm=0&fr=bks0000&word=冒泡排序)[网盘](https://pan.baidu.com/disk/home#/search?from=1027327l&key=冒泡排序)[图片](http://image.baidu.com/search/index?tn=baiduimage&ct=201326592&lm=-1&cl=2&nc=1&ie=utf-8&word=冒泡排序)[视频](https://www.baidu.com/sf/vsearch?pd=video&tn=vsearch&ie=utf-8&rsv_spt=17&wd=冒泡排序)[地图](http://map.baidu.com/m?ie=utf-8&fr=bks0000&word=冒泡排序)[文库](https://wenku.baidu.com/search?lm=0&od=0&ie=utf-8&fr=bks0000&word=冒泡排序)百科

[百度首页](http://www.baidu.com/)

登录

[注册](https://passport.baidu.com/v2/?reg&regType=1&tpl=wk)

[![百度百科](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/logo-baike.svg+xml)](https://baike.baidu.com/#home)



进入词条全站搜索[帮助](https://baike.baidu.com/help)



[![百度百科](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/logo-baike.svg+xml)](https://baike.baidu.com/#home)



进入词条

播报编辑[讨论 8](https://baike.baidu.com/planet/talk?lemmaId=4602306)收藏赞

登录

近期有不法分子冒充百度百科官方人员，以删除词条为由威胁并敲诈相关企业。在此严正声明：百度百科是免费编辑平台，绝不存在收费代编服务，请勿上当受骗！[详情>>](https://baike.baidu.com/common/declaration)



- [首页](https://baike.baidu.com/)

  [历史上的今天](https://baike.baidu.com/calendar)[百科冷知识](https://baike.baidu.com/vbaike)[图解百科](https://baike.baidu.com/vbaike#gallary)

- [秒懂百科](https://baike.baidu.com/item/冒泡排序/4602306#)

  [懂啦](https://child.baidu.com/)[秒懂本尊答](https://baike.baidu.com/item/秒懂本尊答)[秒懂大师说](https://baike.baidu.com/item/秒懂大师说)[秒懂看瓦特](https://baike.baidu.com/item/秒懂看瓦特)[秒懂五千年](https://baike.baidu.com/item/秒懂五千年)[秒懂全视界](https://baike.baidu.com/item/秒懂全视界)

- [特色百科](https://baike.baidu.com/item/冒泡排序/4602306#)

  [数字博物馆](https://baike.baidu.com/museum)[非遗百科](https://baike.baidu.com/feiyi?fr=dhlfeiyi)[恐龙百科](https://baike.baidu.com/wikicategory/view?categoryName=恐龙大全)[多肉百科](https://baike.baidu.com/wikicategory/view?categoryName=多肉植物)[艺术百科](https://baike.baidu.com/art)[科学百科](https://baike.baidu.com/science)

- [用户](https://baike.baidu.com/item/冒泡排序/4602306#)

  [蝌蚪团](https://baike.baidu.com/kedou)[热词团](https://baike.baidu.com/item/百科热词团队)[百科校园](https://baike.baidu.com/campus)[分类达人](https://baike.baidu.com/talent/home/index)[百科任务](https://baike.baidu.com/task)[百科商城](https://baike.baidu.com/mall)

- [知识专题](https://baike.baidu.com/item/冒泡排序/4602306#)

  [大运会](https://baike.baidu.com/activity/knowledge?pageKey=m9b6tAeP-1&cdVersion=0.1.15&channel=baike_pcnavbar)[古鱼崛起](https://baike.baidu.com/activity/knowledge?pageKey=GDZFocOV-1&cdVersion=0.1.15)[食品百科](https://baike.baidu.com/activity/knowledge?pageKey=zQ0sHkZz-1&cdVersion=0.1.15&channel=baike_pcnavbar)[中国航天](https://baike.baidu.com/activity/knowledge?pageKey=0GUwzPFY-1&cdVersion=0.1.15&channel=baike_pcnavbar)[二十四节气](https://baike.baidu.com/activity/knowledge?pageKey=2PhE0FjD-1&cdVersion=0.1.15&channel=baike_pcnavbar)[环游《山海经》](https://baike.baidu.com/activity/knowledge?pageKey=iI2t2a0W-1&cdVersion=0.1.15&channel=baike_pcnavbar)

- [权威合作](https://baike.baidu.com/item/冒泡排序/4602306#)

  [合作模式](https://baike.baidu.com/operation/cooperation#joint)[常见问题](https://baike.baidu.com/operation/cooperation#issue)[联系方式](https://baike.baidu.com/operation/cooperation#connection)

[下载百科APP](https://baike.baidu.com/wapui/subpage/baikeappdownload)

[个人中心](https://baike.baidu.com/usercenter)

# 冒泡排序

播报编辑[讨论8](https://baike.baidu.com/planet/talk?lemmaId=4602306&fromModule=lemma_right-issue-btn)上传视频

计算机科学领域的排序算法

一分钟了解冒泡排序

00:48

简单的算法-冒泡排序

02:34

冒泡排序：像水泡一样，大的元素经不断交换，慢慢浮出水面

01:20

动画学编程之1分钟理解冒泡排序的原理

00:53

「攀博课堂」零基础自学Java教程（029）-冒泡排序

41:25

千锋教育web前端视频JavaScript教程：冒泡排序

07:22

冒泡排序是啥？搞懂冒泡排序只需1分钟，视频演示冒泡排序的原理

00:58

黑车程序员java培训：一线大厂面试专题-12-冒泡排序优化减少冒泡

03:57

Scratch 3.0 算法排序：冒泡排序的动态效果演示

00:17

信息学奥赛经典题源 60题—（55）排序算法系列：冒泡排序算法

75:09

算法与数据结构期末速成15-——冒泡排序算法

02:28

浙江高中信息技术-冒泡排序算法及代码实现(vb)

10:36



收藏

2667

595

本词条由[“科普中国”科学百科词条编写与应用工作项目 ](https://baike.baidu.com/science)审核 。



冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的[排序算法](https://baike.baidu.com/item/排序算法/5399605?fromModule=lemma_inlink)。

它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。

这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同[碳酸饮料](https://baike.baidu.com/item/碳酸饮料/1314261?fromModule=lemma_inlink)中[二氧化碳](https://baike.baidu.com/item/二氧化碳/349143?fromModule=lemma_inlink)的气泡最终会上浮到顶端一样，故名“冒泡排序”。





## 目录

1. 1[算法原理](https://baike.baidu.com/item/冒泡排序/4602306#1)
2. 2[算法分析](https://baike.baidu.com/item/冒泡排序/4602306#2)
3. ▪[时间复杂度](https://baike.baidu.com/item/冒泡排序/4602306#2-1)
4. ▪[算法稳定性](https://baike.baidu.com/item/冒泡排序/4602306#2-2)
5. 3[算法描述](https://baike.baidu.com/item/冒泡排序/4602306#3)
6. ▪[C语言](https://baike.baidu.com/item/冒泡排序/4602306#3-1)
7. ▪[Visual Fox Pro语言](https://baike.baidu.com/item/冒泡排序/4602306#3-2)
8. ▪[Python3](https://baike.baidu.com/item/冒泡排序/4602306#3-3)

1. ▪[Swift](https://baike.baidu.com/item/冒泡排序/4602306#3-4)
2. ▪[C++](https://baike.baidu.com/item/冒泡排序/4602306#3-5)
3. ▪[RUBY](https://baike.baidu.com/item/冒泡排序/4602306#3-6)
4. ▪[PHP](https://baike.baidu.com/item/冒泡排序/4602306#3-7)
5. ▪[C#语言](https://baike.baidu.com/item/冒泡排序/4602306#3-8)
6. ▪[Erlang](https://baike.baidu.com/item/冒泡排序/4602306#3-9)
7. ▪[JAVA](https://baike.baidu.com/item/冒泡排序/4602306#3-10)
8. ▪[Kotlin](https://baike.baidu.com/item/冒泡排序/4602306#3-11)
9. ▪[JavaScript](https://baike.baidu.com/item/冒泡排序/4602306#3-12)

1. ▪[Visual Basic语言](https://baike.baidu.com/item/冒泡排序/4602306#3-13)
2. ▪[Objective-C](https://baike.baidu.com/item/冒泡排序/4602306#3-14)
3. ▪[Go语言](https://baike.baidu.com/item/冒泡排序/4602306#3-15)
4. ▪[GO语言2](https://baike.baidu.com/item/冒泡排序/4602306#3-16)
5. ▪[PASCAL](https://baike.baidu.com/item/冒泡排序/4602306#3-17)
6. ▪[Python](https://baike.baidu.com/item/冒泡排序/4602306#3-18)
7. ▪[汇编](https://baike.baidu.com/item/冒泡排序/4602306#3-19)
8. ▪[lua](https://baike.baidu.com/item/冒泡排序/4602306#3-20)
9. 4[优化](https://baike.baidu.com/item/冒泡排序/4602306#4)

1. 5[算法比较](https://baike.baidu.com/item/冒泡排序/4602306#5)
2. ▪[插入排序](https://baike.baidu.com/item/冒泡排序/4602306#5-1)
3. ▪[选择排序](https://baike.baidu.com/item/冒泡排序/4602306#5-2)
4. ▪[快速排序](https://baike.baidu.com/item/冒泡排序/4602306#5-3)
5. ▪[归并排序](https://baike.baidu.com/item/冒泡排序/4602306#5-4)

## 算法原理

播报

编辑

冒泡[排序算法](https://baike.baidu.com/item/排序算法/5399605?fromModule=lemma_inlink)的原理如下： [1]

1. 1.

   比较相邻的元素。如果第一个比第二个大，就交换他们两个。 [1]

2. 2.

   对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 [1]

3. 3.

   针对所有的元素重复以上的步骤，除了最后一个。 [1]

4. 4.

   持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 [1]

[![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/resize,m_lfit,w_440,limit_1.jpeg)](https://baike.baidu.com/pic/冒泡排序/4602306/0/bf096b63f6246b60965c2634e6f81a4c510fa224?fr=lemma&fromModule=lemma_content-image)冒泡排序流程图

## 算法分析

播报

编辑

### 时间复杂度

若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/0aaf4f8c3ac9f82d6a7882cd121e566b.svg+xml)

 和记录移动次数

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/2a7f4d616d4c16dbf634e349d641b055.svg+xml)

 均达到最小值：

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/03e35724822180365d0d937fbc68b9b2.svg+xml)

 ，

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/9a569e56b84494c24acb31885c070f6f.svg+xml)

 。 [1]

所以，冒泡排序最好的[时间复杂度](https://baike.baidu.com/item/时间复杂度/0?fromModule=lemma_inlink)为

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/f5a1886cf2ff13d73aee4d32d363f66e.svg+xml)

 。

若初始文件是反序的，需要进行

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/dd01d53f50293f756063f87e52c76000.svg+xml)

 趟排序。每趟排序要进行

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/73cdbd7376481a2b19bc38c92d4dd9ff.svg+xml)

 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到[最大值](https://baike.baidu.com/item/最大值/774514?fromModule=lemma_inlink)： [1]

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/51947f4116d1beb324f5a061dac8edbd.svg+xml)

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/2cfa295e83cce099e1ff5afd4f0ba50d.svg+xml)

冒泡排序的最坏时间复杂度为

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/93e1a5d467b4fce05210acb873107e09.svg+xml)

 。 [1]

综上，因此冒泡排序总的平均时间复杂度为

![img](%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/93e1a5d467b4fce05210acb873107e09.svg+xml)

 。 [1]

### 算法稳定性

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 [1]

## 算法描述

播报

编辑

### C语言

```c
?'Original Array ' + CHR(43147)
DIMENSION arr(10)
FOR i = 1 TO 10
    arr(i) = ROUND(rand()*100,0)
ENDFOR
DISPLAY MEMORY LIKE arr
?'After Sort ' + CHR(43147)
FOR i = 1 TO 10
    FOR j = 1 TO 10 - i
        IF arr(j) > arr(j + 1)
            lnTemp = arr(j)
            arr(j) = arr(j + 1)
            arr(j + 1) = lnTemp
        ENDIF
    ENDFOR
ENDFOR
DISPLAY MEMORY LIKE arr
```

### Python3

```python
def bubble_sort(nums):
    for i in range(len(nums) - 1):  # 这个循环负责设置冒泡排序进行的次数
        for j in range(len(nums) - i - 1):  # j为列表下标
            if nums[j] > nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
    return nums

print(bubble_sort([45, 32, 8, 33, 12, 22, 19, 97]))
# 输出：[8, 12, 19, 22, 32, 33, 45, 97]
```

### Swift

```swift
func bubbleSort(_ nums: inout [Int]) {
    let n = nums.count
    for i in 0..<n {
        for j in 0..<(n - 1 - i) {
            if nums[j] > nums[j + 1] {
                nums.swapAt(j, j + 1)
            }
        }
    }
    print(nums)
}

var nums = [1,3,7,8,9]
bubbleSort(&nums)
```

### C++

```c++
#include <iostream>
using namespace std;
template<typename T>
//整数或浮点数皆可使用
void bubble_sort(T arr[], int len)
{
    int i, j;  T temp;
    for (i = 0; i < len - 1; i++)
        for (j = 0; j < len - 1 - i; j++)
        if (arr[j] > arr[j + 1])
        {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
}
int main()
{
    int arr[] = { 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    bubble_sort(arr, len);
    for (int i = 0; i < len; i++)
        cout << arr[i] << ' ';

    cout << endl;

    float arrf[] = { 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 };
    len = (int) sizeof(arrf) / sizeof(*arrf);
    bubble_sort(arrf, len);
    for (int i = 0; i < len; i++)
        cout << arrf[i] << ' ';

    return 0;
}
```

### RUBY

```ruby
def bubbleSort(array)
    return array if array.size < 2
    (array.size - 2).downto(0) do |i|
        (0 .. i).each do |j|
            array[j], array[j + 1] = array[j + 1], array[j] if array[j] >= array[j + 1]
        end
    end
    return array
end
```

### PHP

```php
function bubbleSort($numbers) {
    $cnt = count($numbers);
    for ($i = 0; $i < $cnt - 1; $i++) {
        for ($j = 0; $j < $cnt - $i - 1; $j++) {
            if ($numbers[$j] > $numbers[$j + 1]) {
                $temp = $numbers[$j];
                $numbers[$j] = $numbers[$j + 1];
                $numbers[$j + 1] = $temp;
            }
        }
    }

    return $numbers;
}

$num = array(20, 40, 60, 80, 30, 70, 90, 10, 50, 0);
var_dump(bubbleSort($num));

//输出结果如下：
//array(10) {
//  [0]=>
//  int(0)
//  [1]=>
//  int(10)
//  [2]=>
//  int(20)
//  [3]=>
//  int(30)
//  [4]=>
//  int(40)
//  [5]=>
//  int(50)
//  [6]=>
//  int(60)
//  [7]=>
//  int(70)
//  [8]=>
//  int(80)
//  [9]=>
//  int(90)
//}
```

### C#语言

```c#
冒泡算法C#
namespace 数组排序
{
    class Program
    {
        static void Main(string[] args)
        {
            int temp = 0;
            int[] arr = {23, 44, 66, 76, 98, 11, 3, 9, 7};
            #region该段与排序无关
            Console.WriteLine("排序前的数组：");
            foreach (int item in arr)
            {
                Console.Write(item + "");
            }
            Console.WriteLine();
            #endregion
            for (int i = 0; i < arr.Length - 1; i++)
            {
                #region将大的数字移到数组的arr.Length-1-i
                for (int j = 0; j < arr.Length - 1 - i; j++)
                {
                    if (arr[j] > arr[j + 1])
                    {
                        temp = arr[j + 1];
                        arr[j + 1] = arr[j];
                        arr[j] = temp;
                    }
                }
            #endregion
            }
            Console.WriteLine("排序后的数组：");
            foreach (int item in arr)
            {
                Console.Write(item+"");
            }
            Console.WriteLine();
            Console.ReadKey();
        }
    }
}
```

### Erlang

```erlang
bubble_sort(L)->
bubble_sort(L,length(L)).

bubble_sort(L,0)->
L;
bubble_sort(L,N)->
bubble_sort(do_bubble_sort(L),N-1).

do_bubble_sort([A])->
[A];
do_bubble_sort([A,B|R])->
caseA<Bof
true->[A|do_bubble_sort([B|R])];
false->[B|do_bubble_sort([A|R])]
end.
```

### JAVA

```java
 public static void bubbleSort(int arr[]) {
        for(int i =0 ; i<arr.length-1 ; i++) { 
            for(int j=0 ; j<arr.length-1-i ; j++) {  
                if(arr[j]>arr[j+1]) {
                    int temp = arr[j];   
                    arr[j]=arr[j+1];
                    arr[j+1]=temp;
                }
            }    
        }
    }
```

### Kotlin

```kotlin
fun bubbleSort(array: Array<Int>) { 
   val arrayLength = array.size    
   for (i in 0 until arrayLength) {        
       for (j in 0 until arrayLength - i - 1) {            
           if (array[j] > array[j + 1]) {                
               val temp = array[j]                
               array[j] = array[j + 1]                
               array[j + 1] = temp           
           }       
       }   
   }   
   // Prints result.
}
```

### JavaScript

```js
function bubbleSort(arr) {
    var i = arr.length, j;
    var tempExchangVal;
    while (i > 0) {
        for (j = 0; j < i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                tempExchangVal = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tempExchangVal;
            }
        }
        i--;
    }
    return arr;
}

var arr = [3, 2, 4, 9, 1, 5, 7, 6, 8];
var arrSorted = bubbleSort(arr);
console.log(arrSorted);
alert(arrSorted);
```

[控制台](https://baike.baidu.com/item/控制台/2438626?fromModule=lemma_inlink)将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]

并且[弹窗](https://baike.baidu.com/item/弹窗/10398414?fromModule=lemma_inlink)；

### Visual Basic语言

```visual basic
Sub maopao()
    Dim a = Array(233, 10086, 31, 15, 213, 5201314)
    Dim i As Integer, j As Integer
    
    For i = UBound(a) - 1 To 0 Step -1
        For j = 0 To i
            If a(j) > a(j + 1) Then
                a(j) = a(j) + a(j + 1)
                a(j + 1) = a(j) - a(j + 1)
                a(j) = a(j) - a(j + 1)
            End If
        Next j
    Next i
    For i = 0 To UBound(a)
        Print a(i)
    Next i
End Sub
```

### Objective-C

```objective-c
 for (int i = 0; i<result.count-1; i++) {
        for (int j = 0; j<result.count-1-i; j++) {
            NSInteger left = [result[j] integerValue];
            NSInteger right = [result[j+1] integerValue];
            if (left>right) {
                [result exchangeObjectAtIndex:j withObjectAtIndex:j+1];
            }
        }
    }
NSLog(@"%@",result);
```

### Go语言

```go
package main
import (
    "fmt"
)
const (
    LENGTH = 8
)
func main() {
    var tmp int
    number := []int{95, 45, 15, 78, 84, 51, 24, 12}
    for i := 0; i < LENGTH; i++ {
        for j := LENGTH - 1; j > i; j-- {
            if number[j] < number[j-1] {
                tmp = number[j-1]
                number[j-1] = number[j]
                number[j] = tmp
            }
        }
    }
    for i := 0; i < LENGTH; i++ {
        fmt.Printf("%d ", number[i])
    }
    fmt.Printf("\n")
}
```

### GO语言2

```go
func BubbleSort(values []int) {
    flag := true
    vLen := len(values)
    for i := 0; i < vLen-1; i++ {
        flag = true
        for j := 0; j < vLen-i-1; j++ {
            if values[j] > values[j+1] {
                values[j], values[j+1] = values[j+1], values[j]
                flag = false
                continue
            }
        }
        if flag {
            break
        }
    }
}
```

### PASCAL

```pascal
var
    a:array[1..4] of integer;
    i, j, temp, n:integer;
begin
   read(n);
   for i := 1 to n do read(a[i]);
   for i := 1 to n do
       for j := 1 to n-i do
           if a[j] > a[j + 1] then
               begin
                   temp := a[j];
                   a[j] := a[j + 1];
                   a[j+1] := temp;
               end;
    for i:= 1 to n do write(a[i]);
end.
```

### Python

```python
def bubble(bubbleList):
    listLength = len(bubbleList)
    while listLength > 0:
        for i in range(listLength - 1):
            if bubbleList[i] > bubbleList[i+1]:
                bubbleList[i], bubbleList[i+1] = bubbleList[i+1], bubbleList[i]
        listLength -= 1
    print bubbleList

if __name__ == '__main__':
    bubbleList = [3, 4, 1, 2, 5, 8, 0]
    bubble(bubbleList)
```

### 汇编

```cobol
有一个首地址为A的5个有符号数字的数组，请采用“冒泡”排序
DATAS SEGMENT
A  DW 9,4,26,85,38
DATAS ENDS
CODES SEGMENT
ASSUME CS:CODES,DS:DATAS
START:
    MOV AX,DATAS
    MOV DS,AX
    MOV DI,4;初始化外循环次数为数组个数-1
 LP1:MOV CX,DI;外循环次数初值为数组个数-1
     MOV  BX,0;基址初值BX为0
  LP2:MOV AX,A[BX]
    CMP AX,A[BX+2]
    JGE CONT;大于等于不交换
    XCHG AX,A[BX+2];小于交换,AX保存的为较大的数
MOV A[BX],AX;A[BX]保存的为较大的数，准备进行下一次比较,
  CONT:ADD BX,2;基址初值BX+2,字变量，下一个字偏移地址+2
LOOP LP2  ;内循环次数-1,内循环次数是否为0？
    DEC DI;外循环次数-1
    JNZ LP1;外循环次数是否为0?
    MOV AH,4CH
    INT 21H
CODES ENDS
    END START
```

### lua

```lua
function sortBubble(list)
    local len = #list
    for i = 1, len do
        for j = 1, len-i do
            if list[j+1]>list[j] then
                local t = list[j+1]
                list[j+1] = list[j]
                list[j] = t
            end
        end
    end
end
```

## 优化

播报

编辑

- **针对问题：**

数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。

- **方案：**

设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。

这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。

- 以Java为例

```java
public static void BubbleSort1(int [] arr){
　   int temp;//临时变量
　   boolean flag;//是否交换的标志
　   for(int i=0; i<arr.length-1; i++){   //表示趟数，一共 arr.length-1 次
　       // 每次遍历标志位都要先置为false，才能判断后面的元素是否发生了交换
　       flag = false;
　       for(int j=arr.length-1; j>i; j--){ //选出该趟排序的最大值往后移动
　           if(arr[j] < arr[j-1]){
　               temp = arr[j];
　               arr[j] = arr[j-1];
　               arr[j-1] = temp;
　               flag = true;    //只要有发生了交换，flag就置为true
　           }
　       }
　       // 判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return
　       if(!flag) break;
　   }
　}
```

## 算法比较

播报

编辑

| 排序算法 | 平均时间复杂度 |
| -------- | -------------- |
| 冒泡排序 | O(n²)          |
| 选择排序 | O(n²)          |
| 插入排序 | O(n²)          |
| 希尔排序 | O(n1.5)        |
| 快速排序 | O(N*logN)      |
| 归并排序 | O(N*logN)      |
| 堆排序   | O(N*logN)      |
| 基数排序 | O(d(n+r))      |

### 插入排序

[插入排序](https://baike.baidu.com/item/插入排序/7214992?fromModule=lemma_inlink)算法是基于某序列已经有序排列的情况下，通过一次插入一个元素的方式按照原有排序方式增加元素。这种比较是从该有序序列的最末端开始执行，即要[插入序列](https://baike.baidu.com/item/插入序列/10453584?fromModule=lemma_inlink)中的元素最先和有序序列中最大的元素比较，若其大于该[最大元素](https://baike.baidu.com/item/最大元素/18589088?fromModule=lemma_inlink)，则可直接插入最大元素的后面即可，否则再向前一位比较查找直至找到应该插入的位置为止。插入排序的基本思想是，每次将1个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，寻找最适当的位置，直至全部记录插入完毕。执行过程中，若遇到和插入元素相等的位置，则将要插人的元素放在该相等元素的后面，因此插入该元素后并未改变原序列的前后顺序。插入排序也是一种稳定的排序方法。插入排序分[直接插入排序](https://baike.baidu.com/item/直接插入排序/8255911?fromModule=lemma_inlink)、[折半插入排序](https://baike.baidu.com/item/折半插入排序/8208853?fromModule=lemma_inlink)和[希尔排序](https://baike.baidu.com/item/希尔排序/3229428?fromModule=lemma_inlink)3类。 [2]

### 选择排序

[选择排序](https://baike.baidu.com/item/选择排序/9762418?fromModule=lemma_inlink)算法的基本思路是为每一个位置选择当前最小的元素。选择排序的基本思想是，基于[直接选择排序](https://baike.baidu.com/item/直接选择排序/2090477?fromModule=lemma_inlink)和[堆排序](https://baike.baidu.com/item/堆排序/2840151?fromModule=lemma_inlink)这两种基本的[简单排序](https://baike.baidu.com/item/简单排序/9762200?fromModule=lemma_inlink)方法。首先从第1个位置开始对全部元素进行选择，选出全部元素中最小的给该位置，再对第2个位置进行选择，在剩余元素中选择最小的给该位置即可；以此类推，重复进行“[最小元素](https://baike.baidu.com/item/最小元素/16042946?fromModule=lemma_inlink)”的选择，直至完成第(n-1)个位置的元素选择，则第n个位置就只剩唯一的最大元素，此时不需再进行选择。使用这种排序时，要注意其中一个不同于冒泡法的细节。[举例说明](https://baike.baidu.com/item/举例说明/22894416?fromModule=lemma_inlink)：序列58539．第一遍选择第1个元素“5”会和元素“3”交换，那么原序列中的两个相同元素“5”之间的前后相对顺序就发生了改变。因此，选择排序不是稳定的[排序算法](https://baike.baidu.com/item/排序算法/5399605?fromModule=lemma_inlink)，它在计算过程中会破坏稳定性。 [2]

### 快速排序

[快速排序](https://baike.baidu.com/item/快速排序/2084344?fromModule=lemma_inlink)的基本思想是:通过一趟排序算法把所需要排序的序列的元素分割成两大块，其中，一部分的元素都要小于或等于另外一部分的序列元素，然后仍根据该种方法对划分后的这两块序列的元素分别再次实行[快速排序算法](https://baike.baidu.com/item/快速排序算法/369842?fromModule=lemma_inlink)，排序实现的整个过程可以是[递归](https://baike.baidu.com/item/递归/1740695?fromModule=lemma_inlink)的来进行调用，最终能够实现将所需排序的无序序列元素变为一个有序的序列。 [3]

### 归并排序

[归并排序](https://baike.baidu.com/item/归并排序/1639015?fromModule=lemma_inlink)算法就是把序列递归划分成为一个个短序列，以其中只有1个元素的[直接序列](https://baike.baidu.com/item/直接序列/56544960?fromModule=lemma_inlink)或者只有2个元素的序列作为短序列的递归出口，再将全部有序的短序列按照一定的规则进行排序为长序列。归并排序融合了[分治策略](https://baike.baidu.com/item/分治策略/8399171?fromModule=lemma_inlink)，即将含有n个记录的初始序列中的每个记录均视为长度为1的子序列，再将这n个子序列两两合并得到n/2个长度为2(当凡为奇数时会出现长度为l的情况)的有序子序列；将上述步骤重复操作，直至得到1个长度为n的有序长序列。需要注意的是，在进行元素比较和交换时，若两个元素大小相等则不必刻意交换位置，因此该算法不会破坏序列的稳定性，即归并排序也是稳定的排序算法。 [2]